# It was generated by processing {{ yadm.source }}
# WARNING: Do not edit this file

# set_init: see ~/.bashrc for definition (mainly set -x)

!include dev.justfile

## commented because of !include
# set shell := ["bash", "-uc"]
# set positional-arguments := true
# just := 'just --unstable --justfile "' + justfile() + '"'
# default:
#     {{ just }} --list --unsorted

{% if yadm.class == "personal" %}
doom-clean:
    # https://github.com/millejoh/emacs-ipython-notebook/issues/824
    doom clean
    fd -g '*.elc' {{ env_var('EMACSDIR') }} -uuu -x rm
    doom sync

# Handle stale elc files
doom-rebuild: doom-clean
    doom build -r
    {{ just }} doom-rebuild-pdf-tools
    {{ just }} doom-rebuild-vterm

doom-rebuild-pdf-tools VERSION="29.0.60":
    ## rebuild pdf tools, this fails within emacs because CC is set
    CC= /home/venky/.emacs.d/.local/straight/build-{{ VERSION }}/pdf-tools/build/server/autobuild -i /home/venky/.emacs.d/.local/straight/build-{{ VERSION }}/pdf-tools/

# Rebuild vterm (experimental)
doom-rebuild-vterm:
    emacsclient --eval '(vterm-module-compile)'
    # Look into doomscript: https://github.com/doomemacs/doomemacs/issues/6494

doom-tangle-config:
    emacs --batch -Q --eval "(require 'org)" --eval '(org-babel-tangle-file "{{ env_var('DOOMDIR') }}/config.org")'

[no-cd]
mutagen-project-restart:
    -mutagen project terminate
    mutagen project start

mutagen-sync-monitor:
    mutagen sync list --template="{{{{ json . }}" | jq 'map(select(.labels."io.mutagen.project")) | reduce .[] as $item ({}; .[$item.labels."io.mutagen.project"] = reduce $item as $item2 (.[$item.labels."io.mutagen.project"]; .[$item2.name] = {path: $item2.alpha.path, connected: $item2.alpha.connected, status: $item2.status}) )'

# Log into syslog
syslog-notice NOTICE:
    echo "---Debug notice: {{ NOTICE }}---" | logger -i -s -p user.notice

debug-suspend: (syslog-notice "Suspend")
    systemctl suspend

debug-hibernate: (syslog-notice "Hibernate")
    systemctl hibernate

# Update calibre (run with just sudo update-calibre)
update-calibre: ensure-sudo
    wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sh /dev/stdin
{% endif %}


# Brew capture manually installed "leaves"
brew-dump-leaves:
    brew bundle dump --all --describe --file=- > ~/.Brewfile
    # #!/usr/bin/env bash
    # set_init
    # { brew leaves --installed-on-request; echo "^tap"; } | rg --file - <(brew bundle dump --all --describe --file=-) --before-context 1 --no-line-number --no-context-separator --word-regexp --color=never > ~/.Brewfile

brew-list-used-by:
    # # https://www.thingy-ma-jig.co.uk/blog/22-09-2014/homebrew-list-packages-and-what-uses-them
    brew list --formula -1 | while read formula; do echo -ne "\x1B[1;34m $formula \x1B[0m"; brew uses $formula --installed --recursive --skip-recommended | awk '{printf(" %s ", $0)}'; echo ""; done

brew-list-dependencies:
    brew deps -n --installed --for-each
    # # https://www.thingy-ma-jig.co.uk/blog/22-09-2014/homebrew-list-packages-and-what-uses-them
    # brew list -1 | while read cask; do echo -ne "\x1B[1;34m $cask \x1B[0m"; brew deps $cask --installed | awk '{printf(" %s ", $0)}'; echo ""; done

# We could use this snippet to get <package> <*injected> and then use a just recipe to install
# ❯ cat ~/.pipx.json | jq -cr '.venvs | map_values(.metadata.injected_packages | keys) | to_entries | map(.key + " " + (.value|join(",")))'
# Also see https://github.com/pypa/pipx/issues/687

pipx-update-list:
    pipx list --json --include-injected > ~/.pipx.json


{% if yadm.class == "personal" %}
# Can be reversed w/ dconf load
dconf-dump:
    dconf dump / > ~/.config/dconf/dump.ini

# Reinstalling programmatically seems non-trivial (see
# https://github.com/brunelli/gnome-shell-extension-installer). This atleast
# captures the list
extension-list-dump:
    #!/usr/bin/env bash
    set_x
    EXTENSION_DIR=$HOME/.local/share/gnome-shell/extensions
    cd $EXTENSION_DIR
    fd 'metadata.json' --max-depth 2 -L -x cat | jq -crs > $HOME/.config/gnome-shell-extensions-metadata.json
    fd "^.git$" -uuu --type d --regex --max-depth 2 -L -x bash -c "echo -n {//} ' '; cd {//} && git rev-parse --short HEAD" > $HOME/.config/gnome-shell-extensions-git-revs

save-settings: pipx-update-list brew-dump-leaves dconf-dump
{% else %}
save-settings: pipx-update-list brew-dump-leaves
{% endif %}



yadm-checkpoint:
    cd $HOME && yadm add -u && yadm ci -m "checkpoint" && yadm push

# Install a Jupyter kernel. Requires ipykernel in the env
jupyter-install-ipykernel:
    #!/usr/bin/env bash
    set_init
    cd {{ invocation_directory() }}
    basename=${PWD##*/}
    python -m ipykernel install --user --name="$basename" --env PATH "$PATH"


jupyter-show-kernelspec:
    #!/usr/bin/env bash
    set_init
    cd {{ invocation_directory() }}
    basename=${PWD##*/}
    jupyter kernelspec list --json | dasel -p json '.kernelspecs.'"${basename}"


# # https://github.com/python-poetry/poetry/issues/3958
# # https://github.com/python-poetry/poetry/issues/2921#issuecomment-896812858
# # Update Poetry git dependency
# poetry-reinstall-git LIB:
#     #!/usr/bin/env bash
#     set_init
#     cd {{ invocation_directory() }}
#     if [[ ${POETRY_ACTIVE:-0} -ne 1 ]]; then
#         echo "Poetry is not active"
#         exit 1
#     fi
#     uri=$(dasel select -f pyproject.toml -s '.tool.poetry.dependencies.{{LIB}}.git')
#     rev=$(dasel select -f pyproject.toml -s '.tool.poetry.dependencies.{{LIB}}.rev')
#     poetry remove {{LIB}} && poetry lock && poetry add "git+$uri@$rev"


# Fix ImageMagick resource exhausted errors (convert). Run with just sudo
fix-imagemagick-resources POLICY_XML: ensure-sudo
    #!/usr/bin/env bash
    # https://stackoverflow.com/a/66127712
    set -x
    set -euo pipefail

    # this one is just to solve convertion from .tiff to pdf, you may need it some day
    sed -i '/disable ghostscript format types/,+6d' {{POLICY_XML}}
    sed -i -E 's/name="memory" value=".+"/name="memory" value="8GiB"/g' {{POLICY_XML}}
    sed -i -E 's/name="map" value=".+"/name="map" value="8GiB"/g' {{POLICY_XML}}
    sed -i -E 's/name="area" value=".+"/name="area" value="8GiB"/g' {{POLICY_XML}}
    sed -i -E 's/name="disk" value=".+"/name="disk" value="8GiB"/g' {{POLICY_XML}}

# path := env_var('PATH')

# Note: this won't work with set_init since $HOME/.bashrc isn't loaded (use the
# shebang below):
#    #!/usr/bin/env -S bash --init-file ${HOME}/.bashrc
#
# Run via sudo, preserving env and PATH
sudo *CMD:
    sudo -E --preserve-env=PATH,ABDUCO_SOCKET_DIR env {{CMD}}


# - this seems to be problematic and I haven't figure out how to make it work well:
#
#   1. --use-source-timestamp is essential or it updates the file, and is then triggered by that update
#
#   2. watching both files and syncing them in the command will also lead to
#      infinite loop. no combination of --on-busy-update, --debounce,
#      --watch-when-idle etc seems to fix it
#
#   3. sometimes there is a change which isn't in the variables we're passing into parallel, and then parallel will think it's reading stdin and break
#
# A better approach is probably to use on-save hooks in Emacs
#
# Sync a Jupyter nb file to a Python file using Jupytext
# jupytext-sync NBFILE meta=env_var_or_default('meta', 'true') poll=env_var_or_default('poll', '2000'):
#     #!/usr/bin/env bash
#     set_init
#     cd {{ invocation_directory() }}
#
#     nbfile=$(realpath {{ NBFILE }})
#     [[ -e "$nbfile" ]] || (echo "$nbfile not found" && exit 1)
#
#     pyfile=$(dirname $nbfile)/"$(basename $nbfile .ipynb).py"
#     jupytext --set-formats ipynb,py:percent --sync --quiet --output "$pyfile" "$nbfile" && echo "Revert the notebook or it won't be synced"
#
#     meta_opt="{{ if meta == 'true' { '' } else { '--no-meta' } }}"
#     poll_opt="{{ if poll == '0' { '' } else { '--force-poll ' + poll } }}"
#     add_vars_to_watch="{{ if meta == 'true' { '\$WATCHEXEC_META_CHANGED_PATH' } else { '' }  }}"
#
#     watchexec -w "$nbfile" -w "$pyfile" ${meta_opt} --watch-when-idle --postpone --on-busy-update=do-nothing --print-events ${poll_opt} 'parallel --verbose --delimiter : "jupytext --update --quiet --sync --use-source-timestamp $WATCHEXEC_COMMON_PATH/{}" ::: $WATCHEXEC_WRITTEN_PATH '${add_vars_to_watch}
#     # watchexec -w $nbfile -w $pyfile --no-meta -p "jupytext --sync $nbfile"

jupytext-sync nb_or_script:
    cd {{ invocation_directory() }} && jupytext --sync --use-source-timestamp {{ nb_or_script }}

jupytext-unpair nb_or_script:
    cd {{ invocation_directory() }} && jupytext --set-formats {{ extension(nb_or_script) }} {{ nb_or_script }}

# jupytext -p doesn't work if we put formats: [ipynb, py:percent] in jupytext.toml
# https://github.com/mwouts/jupytext/issues/928
jupytext-is-managed nb:
    cd {{ invocation_directory() }} && jq -e '(.metadata.jupytext | length) > 0' {{ nb }}

# If it is managed, and there is a formats key, then it is not the default [ipynb,py:percent]
jupytext-is-not-default-paired nb:
    {{ just }} jupytext-is-managed {{ nb }} && jq -e '.metadata.jupytext.formats == null' {{ nb }}

# Rename a pair of py/ipynb files
jupytext-rename-pair nb_or_script newname_without_ext:
    #!/usr/bin/env bash
    set_x
    cd {{ invocation_directory() }}
    mv {{ nb_or_script }} {{ join(parent_directory(nb_or_script), newname_without_ext + "." + extension(nb_or_script)) }}
    complement_ext={{ if extension(nb_or_script) == 'ipynb' { '.py' } else { '.ipynb' } }}; mv {{ without_extension(nb_or_script) }}$complement_ext {{ join(parent_directory(nb_or_script), newname_without_ext) }}$complement_ext

ensure-sudo:
    #!/usr/bin/env bash
    if [[ $EUID -ne 0 ]]; then
        echo "Invoke with 'just sudo just CMD'"
        exit 1
    fi

glances plugins=env_var_or_default("plugins", "") *args='':
    glances --sparkline --disable-plugin all --enable-plugins=quicklook,cpu,gpu,mem,load,processcount,processlist,docker,{{plugins}} {{ args }}


dl *cmd:
    {{ just }} subjust "/home/venky/dev/gcloud/gcpvm --dotenv-filename=/home/venky/dev/gcloud/deeplearning-1-vm.env" "$@"

pregen *cmd:
    {{ just }} subjust "/home/venky/dev/gcloud/gcpvm --dotenv-filename=/home/venky/dev/gcloud/prod-pregenerate.env" "$@"

# conda-create-env:
#     #!/usr/bin/env bash
#     set_x
#     cd {{ invocation_directory() }}
#     if [[ -d .venv ]]; then
#        echo ".venv already exists"
#        exit 1
#     fi
#     conda create --prefix .venv --yes --quiet
#     echo 'layout_anaconda ./.venv' > .envrc
#     direnv allow && direnv reload

# conda-update-env:
#     cd {{ invocation_directory() }} && \
#        test -f environment.yml && \
#        test -d ./.venv && \
#        mamba env update -p ./.venv --file environment.yml --prune

[no-cd]
dvc_data_status json='no':
    dvc data status --granular --unchanged --untracked-files=all {{ if json == 'yes' { "--json" } else { '' } }}

[no-cd]
dvc_du:
    {{ just }} dvc_data_status 'yes' | jq -r '.unchanged[]' | xargs -IARG du -h "ARG" | sort -h

# Run command in abduco and capture log
abduco +args:
    #!/usr/bin/env bash
    set -x
    name=${ABDUCO_NAME:-$(echo "{{ args }}" | perl -lne 's/\s+/-/g; print substr($_, 0, 25)')}
{% if yadm.os == "Darwin" %}
    cd {{ invocation_directory() }} && abduco -nf ${name} script -F -q ${name}.log zsh -ic "{{ args }}" && tail -F ${name}.log
{% endif %}
{% if yadm.os == "Ubuntu" %}
    cd {{ invocation_directory() }} && abduco -nf ${name} script -O ${name}.log --return -c "{{ args }}" && tail -F ${name}.log
{% endif %}

abduco_connect:
{% if yadm.os == "Ubuntu" %}
    abduco -a $(abduco | fzf | awk '{print $4}')
{% endif %}
{% if yadm.os == "Darwin" %}
    abduco -a $(abduco | fzf | awk '{print $5}')
{% endif %}

# cleans up completed sessions (But not their logs)
abduco_cleanup:
    abduco | rg '^\+' | cut -f 3 | xargs -tr -n1 abduco -Ar

# Flushes logs from `script`
abduco_flush:
{% if yadm.os == "Ubuntu" %}
    pkill --signal SIGUSR1 -x "script"
{% endif %}
{% if yadm.os == "Darwin" %}
    pkill -SIGUSR1 -x "script"
{% endif %}

[no-cd]
tmuxrun +args:
    #!/usr/bin/env bash
    set -x
    name=${ABDUCO_NAME:-$(echo "{{ args }}" | perl -lne 's/\s+/-/g; print substr($_, 0, 25)')}
    logfile="${name}.log"
    tmux new-session -d -s $name
    tmux send-keys -t $name "{{ args }} 2>&1 | tee $name.log" C-m
    tmux send-keys -t $name "tmux kill-session -t $(tmux display-message -p '#S')" C-m
    tail -F $name.log

tmux_connect:
    tmux attach -t $(tmux list-sessions -F "#{session_name}" | fzf )


# shutdown GCP vm after some interval
shutdown_after time:
    {{ just }} abduco shutdown "termdown {{ time }} && sudo poweroff"

wait_for_pid pid:
    # https://stackoverflow.com/a/41613532/14044156
    tail --pid={{ pid }} -f /dev/null

duplicacy_root:
    #!/usr/bin/env bash
    set_x
    cd /; pkexec env PATH=$PATH dotenv -f $HOME/.config/duplicacy/mxp_root/env run duplicacy -log backup -storage b2_mxp_root -stats

duplicacy_home:
    #!/usr/bin/env bash
    set_x
    cd $HOME; dotenv -f $HOME/.config/duplicacy/mxp_home_venky/env run duplicacy -log backup -storage b2_mxp_home_venky -stats

[no-cd]
subjust justcmd *cmd:
    {{ justcmd }} -- "${@:2}"

gitignore_specific_files:
    #!/usr/bin/env python

    from pathlib import Path
    import sys
    from typing import Generator

    def all_parents(p: Path) -> Generator[Path, None, None]:
        p = p.parent
        while True:
            if p.parent != p:
                yield p
            else:
                return
            p = p.parent

    def main():
        input_paths = [Path(p.strip()) for p in sys.stdin.readlines()]
        parent_paths = set()
        for p in input_paths:
            parent_paths.update(all_parents(p))
        for p in sorted(parent_paths):
            print(f'!{p}')
            print(f'{p}/*')
        for p in input_paths:
            print(f'!{p}')

    if __name__ == '__main__':
        main()

# Generate yadm files that aren't gitignored, for sync
yadm_ls_files_for_mutagen:
    yadm list -a | {{ just }} gitignore_specific_files | jq -R '.' | jq -s '.' | dasel -r json -w yaml > $HOME/.config/yadm/yadm_ls_files_for_mutagen.yml

# after we add new files to yadm, update the sync
yadm_sync_restart: yadm_ls_files_for_mutagen
    yadm alt && cd ~/.config/yadm && {{ just }} mutagen-project-restart

[no-cd]
tmux_split name *CMD:
    #!/usr/bin/env bash
    if ! tmux has-session -t {{ name }} &> /dev/null; then
      tmux new-session -d -s {{ name }} "${@:2}"
    else
      tmux split-window -t {{ name }}:0 -v "${@:2}" \; select-layout "tiled"
    fi

[no-cd]
multitail +files:
    echo {{ files }} | xargs -t -n1 {{ just }} tmux_split multitail tail -F
    tmux attach -t multitail


[no-cd]
parent_dirs stop_at=env_var('HOME'):
    #!/usr/bin/env bash
    # set_x
    dir="$(pwd)"
    while [ "$dir" != {{ stop_at }} ]; do
        echo "$dir"
        dir="$(dirname "$dir")"
    done
    echo {{ stop_at }}

[no-cd]
find_up +patterns:
    #!/usr/bin/env bash
    # set_x
    for dir in $({{ just }} parent_dirs $HOME); do
        for pattern in {{ patterns }}; do
            f="$dir/$pattern"
            if [ -e $f ]; then
                echo $f
            fi
        done
    done


[no-cd]
fzf_choose:
    # this won't work for recipes with args; for that we need to define a zle widget
    just --unstable $({{ just }} find_up .justfile justfile | \
        xargs -n1 just --unstable  --list --list-heading= --list-prefix= -f | fzf | choose 0)




# Local Variables:
# mode: just
# eval: (firestarter-mode)
# firestarter: "yadm alt"
# End:
